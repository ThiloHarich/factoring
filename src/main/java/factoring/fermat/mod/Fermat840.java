package factoring.fermat.mod;

import factoring.fermat.FermatFact;
import factoring.math.PrimeMath;
import factoring.math.SquaresMod;

import java.util.Collection;

import static factoring.math.PrimeMath.mod;

/**
 * Created by Thilo Harich on 21.12.2017.
 *
 * uses the modulo 840 = 2^3 * 3 * 5 * 7
 * x^2 - n*m = y^2 modulo 840
 *
 * m is chosen such that n*m = 47 -> m = 47 * n^-1
 * then there are only the following 12 solutions for x
 * 24,816,84,756,144,696,276,564,336,504,396,444
 * This gives a speedup of 70 (=840/12) over the regular fermat method.
 *
 * The fact that (-x)^2 = x^2 drills down the number generated by the function x^2 mod p
 * for a prime by a factor of ~ 2.
 * applying multiple primes cuts down the number of generated numbers by 2 per prime.
 * the  solutions for  x^2 - n = y^2 modulo 840 ,
 * gcd(n, 840) = 1 has in average around 34 solutions.
 *
 * Using a multiplier has two advantages :
 * <li>the solutions for x are fixed and can be calculated in advance -> makes the program simple</li>
 * <li>The number of solutions goes down from around 34 to 12 solutions. This gives another speedup of ~ 3 </li>
 */
public class Fermat840 extends FermatFact {

    static int mod = 840;
//    static int [] xSolutions = {24,816,84,756,144,696,276,564,336,504,396,444};
    static int [] xSolutions = {24,84,144,276,336,396,444,504,564,696,756,816};

    @Override
    public long findFactors(long n, Collection<Long> factors) {
        int smallFactor = 3;

        for (; smallFactor <= 7; smallFactor +=2)
        if (n%smallFactor == 0)
        {
            if (n/smallFactor > 1)
                factors.add(n/smallFactor);
            return smallFactor;
        }
        smallFactor = 11;
        int multiplier = 1;
//        if (n > mod) {
            // now we can assume that we can always find an inverse of n mod 840
            long nInvers = PrimeMath.invert(n, mod);
            multiplier = mod(47 * nInvers, mod);
            int multiplied = mod(multiplier * n, mod);
            if (multiplied != 47) {
                System.out.println("XXXX");
            }
//        }
        long nMultiplied = multiplier*n;
        // the multiplier moves the x begin up
        long xBegin = (PrimeMath.sqrt(n) * (multiplier + 1)) / 2;
        xBegin = (xBegin / mod) * mod;
        long xEnd = (n*multiplier + smallFactor*smallFactor*multiplier) / (smallFactor*2);
        for (int i=0; i < xSolutions.length; i++) {
            long xSol = xSolutions[i];
            for (long x = xBegin + xSol; x <= xEnd; x+=mod) {
                long right = x * x - nMultiplied;
                if (SquaresMod.isSquare(right)) {
                    long y = PrimeMath.sqrt(right);
                    long factor2 = x - y;
                    // handle the multiplier
                    if (factor2 % multiplier == 0 && factor2 > multiplier)
                        factor2 = factor2 / multiplier;
                    if (n % factor2 == 0) {
                        long factor1 = n / factor2;
                        if (factor1 != 1)
                            factors.add(factor1);
                        return factor2;
                    }
                }
            }
        }
        return n;
    }
}